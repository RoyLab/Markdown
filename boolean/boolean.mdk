Title         : Boolean 笔记
Author        : 王睿 [reference manual]
Logo          : TrueFalse

[TITLE]


# 预处理
## Mesh的处理
* 归一化坐标系，到0~1
* 去掉多余的位数，保留18位，最小边长为0.25
* 获取每个面，以及整个Mesh的bbox

## CSG树的预处理
* 应用De Morgan律


# 八叉树构建
* 获取八叉树bbox的大小，适当增长
* 分割，碰撞检测，并记录混合子节点

# 相交测试
* 遍历所有的混合子节点
* 如相交：分情况
  * 点相交：直接无视，因为单独的点相交会产生non-manifold，非单独的点，
  一定会属于某一个折痕。
  * 线相交： 应该录入，但有一种情况除外，就是它是某个三角形边的一部分。
  这种情况下，有可能出现non-manifold；此外，还有可能出现同一个折痕被录入两次的情况。可以通过
  测试share临边的两个三角形跟主三角形的位置的关系来判断。
    * 1，0，这种情况下记录，并且在对应的位置上记录下共面的标记，如果某一个区域被这个标记包围，
    说明这个区域应当被视为共面
    * 1，1，不记录
    * 1，-1，记录
    
  * 面相交：直接记录，但不录入任何数据，因为面相交的边缘都是线段，这些线段一
  定会被记录下来。
  * 这里存在一个On的标记，即某个点，无论第一类点还是生成点，如果在别的mesh上，则标一个On，很有用处。
  这个标记必须是mesh内共享的，特指点标记和边标记
  * 记录的分类体现了是否需要[tesselate]{ :red }这个问题

* 录入时，注意检查对应的位置有没有已经存在的顶点。为了可以检查闭环，每个顶点要存
储一下连接了那些折痕。
* 合并原则：每次相交测试，会有两个点，这两个点，可能是原生的，也可能是新
成的，但新生成的也可能会是重复的。如果发现重复，那么指向ID小的那个面对应的点。
* 新的looplet技术值得借鉴，但looplet并不需要在此刻添加。

## 指针结构

我们需要一个两层结构

* 首先是一个agency，用于被存储的位置指向它。
* 然后是agency指向实体，这样可以用于合并agency。
* 每次相交测试生成一个agency，如果存在不同的agency，则合并它们。

# 染色
## 初始化

显然从某一个面开始染色，然后继续遍历。

随机初始化一个点的完全向量。

## 处理复杂面

* 首先得到二级向量。
* 过滤掉无用折痕。
* 建立图，找寻第三类点
* 从某一个点开始，染色图，这里的准确性跟On相关。
* 添加looplet
* 连接looplet，栅格化，convex化，三角化

### 染色图问题： 

* 必须存在上下文结构，在共享点的位置。非共享点的上下文本身存在。内点=单面，边点=双面，角点=所有面，给引用就可以了
* 单面单投，多面，角度近的算。

## 传递问题：

* 向下传递——使用子集
* 向上传递——使用边缘点

## 选面问题

* 主要是On的存在，如果全On，会出现多种可能。使用共面标记有助于判断共面。
如果不是共面，就用其中一个边的构造面做测试。

## looplet问题


# Issue

* 三角形构建可以只放在OctreeBuilding?
* 由于实体点放在最终result mesh当中，所以要清理不用的点。


# 3.7

## 讨论统一表示的需求

### Indicator计算

从一个full的点出发，逐步flood filling到整个的网格当中。这里的问题在于，如果遇到On点，则为On。如果On点之后不是On，
则基于之前的整个On点给出分类。这里的[On点要给出上下文环境]{ :red }。如果所有的环境给出的意见一致，
则取这个标记；如不一致，选择方位角最小的那个信。不过这里，肯定会用到三角形的边界条件，
光是用法向是没有用的，因为法向在此刻有二义性。

孤岛问题：发射孤岛上的一个顶点到已有网络的某一个full indicator点。计算线段与三角形的相交数，
奇数次变号，偶数次不变号。当然也可以用ray cast算法，毕竟这种情况稀少。

边上的点要至少算出一个全Indicator，用于传染。

### 圈地算法

从一个点出发，没岔路最好，有岔路的点应当有岔路标记。只走相邻边围地。  
这里的关键问题是如何判断顺序？  
Looplet方法中给了一些提示，但这些提示在我们的算法工作的并不是很好。主要是这里做的相交测试跟looplet
并不同。所以looplet要手动生成。四象限问题。象限用点积和叉积的符号算。

两种特殊而常见的pattern：内部点，无岔道；边点，三岔道。

#### 如何判断角的大小：

首先算一下点到面的距离。然后取倒数，区分二义性。二义性可以用求点积的方法，或者垂直线的方法。
随便选，性能并不重要。感觉looplet最好放在建立图的时候就建立。

### 如何判断圈好的面积的Indicator

一般来说点是面积的采样。点如果是In/Out，那根据连续性原理，面积也是。但On存在歧义。  
On带来的二义性可以通过某一个In/Out消除。如果一个都没有，那这个面积可能是In/Out/On.  
边环境：如果出现重合边，大几率On面积。只需要测试这个On的面的第三个点，是否在现在这个looplet的左边。
如果在，这整个为On,如果不在，则由第三个点，以及非Coplanar的关系决定。

### 最终的result mesh的构造

所有的点都放进去，最后去掉孤立点。√
所有的点只在需要放的时候再放进去。


## 讨论构造统一算法

### 点的属性

属于一些mesh，每个mesh都有上下文。

### 边的属性

属于一些mesh，每个mesh都有上下文。

### 上下文的构成

原生点：直接给点的handle；边点：两个边的handle；面点：面的引用；


### looplet

先解析边界的点，完了把内部接触到的点做个标记。
注意这里有有洞的点的问题。


### ！！并不需要边上的信息

* looplet可以重复，不一定要全部使用，寻找最近的点作为接应点。待验证。  
* 不需要边上的信息，这个信息完全可以从点中retrieve出来。  
* 关于On的判定，可以连续找三个不共线的，然后判别那个coplanar面的方向和这个三个点形成的方向是否一致。




[reference manual]: http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html  "Madoko refrence manual"